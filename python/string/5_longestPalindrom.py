# 题目描述
# 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
#
# 示例 1：
#
# 输入: "babad"
# 输出: "bab"
# 注意: "aba" 也是一个有效答案。
# 示例 2：
#
# 输入: "cbbd"
# 输出: "bb"

# 解题思路1: 动态规划, 以下阶梯思路来源于LeetCode:
# https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/
# 这道题比较烦人的是判断回文子串。因此需要一种能够快速判断原字符串的所有子串是否是回文子串的方法，于是想到了“动态规划”。
#
# “动态规划”最关键的步骤是想清楚“状态如何转移”，事实上，“回文”是天然具有“状态转移”性质的：
#
# 一个回文去掉两头以后，剩下的部分依然是回文（这里暂不讨论边界）。
#
# 依然从回文串的定义展开讨论：
#
# 1、如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；
#
# 2、如果一个字符串的头尾两个字符相等，才有必要继续判断下去。
#
# （1）如果里面的子串是回文，整体就是回文串；
#
# （2）如果里面的子串不是回文串，整体就不是回文串。
#
# 即在头尾字符相等的情况下，里面子串的回文性质据定了整个子串的回文性质，这就是状态转移。因此可以把“状态”定义为原字符串的一个子串是否为回文子串。
#
# 第 1 步：定义状态
# dp[i][j] 表示子串 s[i, j] 是否为回文子串。
#
# 第 2 步：思考状态转移方程
# 这一步在做分类讨论（根据头尾字符是否相等），根据上面的分析得到：
#
# dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
# 分析这个状态转移方程：
#
# （1）“动态规划”事实上是在填一张二维表格，i 和 j 的关系是 i <= j ，因此，只需要填这张表的上半部分；
#
# （2）看到 dp[i + 1][j - 1] 就得考虑边界情况。
#
# 边界条件是：表达式 [i + 1, j - 1] 不构成区间，即长度严格小于 2，即 j - 1 - (i + 1) + 1 < 2 ，整理得 j - i < 3。
#
# 这个结论很显然：当子串 s[i, j] 的长度等于 2 或者等于 3 的时候，我其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。
#
# 如果子串 s[i + 1, j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，当然是回文；
# 如果子串 s[i + 1, j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。
# 因此，在 s[i] == s[j] 成立和 j - i < 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。
#
# （这一段看晕的朋友，直接看代码吧。我写晕了，车轱辘话来回说。）
#
# 第 3 步：考虑初始化
# 初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 1，即 dp[i][i] = 1 。
#
# 事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。
#
# 第 4 步：考虑输出
# 只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，因为截取字符串也要消耗性能，记录此时的回文子串的“起始位置”和“回文长度”即可。
#
# 第 5 步：考虑状态是否可以压缩
# 因为在填表的过程中，只参考了左下方的数值。事实上可以压缩，但会增加一些判断语句，增加代码编写和理解的难度，丢失可读性。在这里不做状态压缩。
#
# 下面是编码的时候要注意的事项：总是先得到小子串的回文判定，然后大子串才能参考小子串的判断结果。
#
# 思路是：
#
# 1、在子串右边界 j 逐渐扩大的过程中，枚举左边界可能出现的位置；
#
# 2、左边界枚举的时候可以从小到大，也可以从大到小。
#
# 这两版代码的差别仅在内层循环，希望大家能够自己动手，画一下表格，思考为什么这两种代码都是可行的，相信会对“动态规划”作为一种“表格法”有一个更好的理解。
#
# 复杂度分析：
#
# 时间复杂度：O(N^{2})O(N
# 2
#  )。
# 空间复杂度：O(N^{2})O(N
# 2
#  )，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是 O(N^{2})O(N
# 2
#  )。
# 写完代码以后，读者可以纸上写下代码运行的流程，以字符串 'babad' 为例：
#
#
class Solution(object):
    def longestPalindrome(self, s):
        if not s or len(s) < 2:
            return s
        n = len(s)
        # 定义dp初始状态
        dp = [[False for _ in range(n)] for _ in range(n)]
        # 初始化dp中单个字符一定为回文子串
        for i in range(n):
            dp[i][i] = True

        # dp状态转移
        max_len = 0
        for j in range(1, n):
            for i in range(0, j):
                if s[i] == s[j]:
                    if j - i < 3:
                        dp[i][j]= True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                else:
                    dp[i][j] = False

                if dp[i][j]:
                    cur_len = j - i + 1
                    if cur_len > max_len:
                        max_len = cur_len
                        start = i
        return s[start:start + max_len]

