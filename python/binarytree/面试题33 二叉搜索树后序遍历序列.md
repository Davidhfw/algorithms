# 面试题33 二叉搜索树后序遍历序列

## 递归分治

### 解题思路

- 后序遍历定义：左子树->右子树->根节点。
- 二叉搜索树定义：左子树中所有节点的值<根节点的值；右子树中所有节点的值>根节点的值；其左右子树也分别是二叉搜索树。

### 方法1：递归分治

根据二叉搜索树的定义，可以通过递归，判断所有子树的正确性（即其后序遍历是否满足二叉搜索树的定义），若所有子树都正确，则此序列为二叉搜索树的后序遍历。

**递归解析：**

- 终止条件：当`i>=j`，说明此子树节点数量<=1，无需判断正确性，直接翻译true；
- 递推工作：
  - 1. 划分左右子树：遍历后序遍历的[i, j]区间元素，寻找第一个大于根节点的节点，索引记为m。此时，可划分出左子树区间[i, m - 1]、右子树区间[m, j - 1]、根节点索引j。
    2. 判断是否为二叉搜索树：
       - 左子树区间[i, m - 1]内的所有节点都应<postorder[j]。而1.划分左右子树步骤已经保证了左子树区间的正确性，因此只需要判断右子树区间即可。
       - 右子树区间[m, j - 1]内的所有节点都应>postorder[j]。实现方式为遍历，当遇到<=postorder[j]的节点则跳出；否则可通过p==j判断是否为二叉搜索树。

- 返回值：所有子树都序正确才能判定正确，因此必须使用与逻辑符连接。
  1. p == j，判断此树是否正确。
  2. Recur(i, m - 1)：判断此树的左子树是否正确；
  3. recur(m, j - 1)：判断此树的右子树是否正确；

#### 复杂度分析

- 时间复杂度：O(N*N)
- 空间复杂度：O(N)

`

```python
def verify_post_order(post_order):
    def recur(i, j):
        # 节点遍历结束
        if i >= j:
            return True
        p = i
        # 左子树所有节点值大于根节点值
        while post_order[p] < post_order[j]:
            p += 1
        m = p
        # 右子树所有节点值大于根节点值
        while post_order[p] > post_order[j]:
            p += 1
        # 递归遍历左右子序列
        return p == j and recur(i, m -1) and recur(m, j - 1)
    return recur(0, len(post_order) - 1)


post_order = [1, 3, 2, 6, 5]
print(verify_post_order(post_order))
```

`

